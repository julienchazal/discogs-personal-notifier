/* src/Search.svelte generated by Svelte v3.20.1 */
import { SvelteComponentDev, add_location, append_dev, attr_dev, destroy_each, detach_dev, dispatch_dev, element, globals, init, insert_dev, listen_dev, noop, safe_not_equal, set_data_dev, set_input_value, space, text, validate_each_argument, validate_slots } from "/dist/web_modules/svelte/internal.js";
const {
  console: console_1
} = globals;
const file = "src/Search.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-zl324n-style";
  style.textContent = ".search.svelte-zl324n{text-align:center}input.svelte-zl324n{font-size:16px;background:aliceblue;border-top:none;border-left:none;border-right:none;border-bottom:1px solid #41adff;padding:1rem;width:100%}ul.svelte-zl324n{padding:0;margin:0;list-style-type:none}li.svelte-zl324n{display:flex;align-items:center;justify-content:space-between;padding:1rem 0.5rem}img.svelte-zl324n{width:40px;height:40px;border-radius:50%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VhcmNoLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGxldCBzZWFyY2ggPSAnJztcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGxldCBxLCByZXM7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZWFyY2hGbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3EgPSAnK3NlYXJjaClcbiAgICAgICAgcSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5kaXNjb2dzLmNvbS9kYXRhYmFzZS9zZWFyY2g/cT0nK3NlYXJjaCsnJnR5cGU9cmVsZWFzZSZrZXk9ek9YSWdCV1lJT09YQWlEcWxmTHMmc2VjcmV0PU9Xa1RUcmpIcHpEVGRZQUJTSW1FSlBBRWt1YkFJcUtWJyk7XG4gICAgICAgIHJlcyA9IGF3YWl0IHEuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICByZXN1bHRzID0gcmVzLnJlc3VsdHM7XG4gICAgfVxuXG4gICAgJDogaWYgKHNlYXJjaCAhPT0gJycpIHtcbiAgICAgICAgc2VhcmNoRm4oKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInNlYXJjaFwiPlxuICAgIDxpbnB1dCB0eXBlPVwic2VhcmNoXCIgYmluZDp2YWx1ZT17c2VhcmNofSBwbGFjZWhvbGRlcj1cIkJsYWNrIGFsYnVtLCBSaWVuLi4uXCI+XG4gICAgPGRpdj5cbiAgICAgICAgPHVsPlxuICAgICAgICAgICAgeyNlYWNoIHJlc3VsdHMgYXMgcn1cbiAgICAgICAgICAgICAgICA8bGkgZGF0YS1pZD1cIntyLmlkfVwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIntyLnRodW1ifVwiIGFsdD1cIlwiPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57ci50aXRsZX08YnI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCByLmZvcm1hdCBhcyBmfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGVtPntmfSAvPC9lbT5cbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntyLnllYXJ9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5zZWFyY2gge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuICAgIGlucHV0IHtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBiYWNrZ3JvdW5kOiBhbGljZWJsdWU7XG4gICAgICAgIGJvcmRlci10b3A6IG5vbmU7XG4gICAgICAgIGJvcmRlci1sZWZ0OiBub25lO1xuICAgICAgICBib3JkZXItcmlnaHQ6IG5vbmU7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNDFhZGZmO1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gICAgdWwge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgICB9XG4gICAgbGkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIHBhZGRpbmc6IDFyZW0gMC41cmVtO1xuICAgIH1cbiAgICBpbWcge1xuICAgICAgICB3aWR0aDogNDBweDtcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgfVxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0NJLE9BQU8sY0FBQyxDQUFDLEFBQ0wsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUNELEtBQUssY0FBQyxDQUFDLEFBQ0gsU0FBUyxDQUFFLElBQUksQ0FDZixVQUFVLENBQUUsU0FBUyxDQUNyQixVQUFVLENBQUUsSUFBSSxDQUNoQixXQUFXLENBQUUsSUFBSSxDQUNqQixZQUFZLENBQUUsSUFBSSxDQUNsQixhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ2hDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBQ0QsRUFBRSxjQUFDLENBQUMsQUFDQSxPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxDQUFDLENBQ1QsZUFBZSxDQUFFLElBQUksQUFDekIsQ0FBQyxBQUNELEVBQUUsY0FBQyxDQUFDLEFBQ0EsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsYUFBYSxDQUM5QixPQUFPLENBQUUsSUFBSSxDQUFDLE1BQU0sQUFDeEIsQ0FBQyxBQUNELEdBQUcsY0FBQyxDQUFDLEFBQ0QsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxHQUFHLEFBQ3RCLENBQUMifQ== */";
  append_dev(document.head, style);
}

function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
} // (27:20) {#each r.format as f}


function create_each_block_1(ctx) {
  let em;
  let t0_value =
  /*f*/
  ctx[9] + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      em = element("em");
      t0 = text(t0_value);
      t1 = text(" /");
      add_location(em, file, 27, 24, 805);
    },
    m: function mount(target, anchor) {
      insert_dev(target, em, anchor);
      append_dev(em, t0);
      append_dev(em, t1);
    },
    p: function update(ctx, dirty) {
      if (dirty &
      /*results*/
      2 && t0_value !== (t0_value =
      /*f*/
      ctx[9] + "")) set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(em);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(27:20) {#each r.format as f}",
    ctx
  });
  return block;
} // (23:12) {#each results as r}


function create_each_block(ctx) {
  let li;
  let img;
  let img_src_value;
  let t0;
  let span0;
  let t1_value =
  /*r*/
  ctx[6].title + "";
  let t1;
  let br;
  let t2;
  let t3;
  let span1;
  let t4_value =
  /*r*/
  ctx[6].year + "";
  let t4;
  let t5;
  let li_data_id_value;
  let each_value_1 =
  /*r*/
  ctx[6].format;
  validate_each_argument(each_value_1);
  let each_blocks = [];

  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }

  const block = {
    c: function create() {
      li = element("li");
      img = element("img");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      br = element("br");
      t2 = space();

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      t5 = space();
      if (img.src !== (img_src_value =
      /*r*/
      ctx[6].thumb)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "");
      attr_dev(img, "class", "svelte-zl324n");
      add_location(img, file, 24, 20, 670);
      add_location(br, file, 25, 35, 734);
      add_location(span0, file, 25, 20, 719);
      add_location(span1, file, 30, 20, 896);
      attr_dev(li, "data-id", li_data_id_value =
      /*r*/
      ctx[6].id);
      attr_dev(li, "class", "svelte-zl324n");
      add_location(li, file, 23, 16, 628);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, img);
      append_dev(li, t0);
      append_dev(li, span0);
      append_dev(span0, t1);
      append_dev(span0, br);
      append_dev(span0, t2);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span0, null);
      }

      append_dev(li, t3);
      append_dev(li, span1);
      append_dev(span1, t4);
      append_dev(li, t5);
    },
    p: function update(ctx, dirty) {
      if (dirty &
      /*results*/
      2 && img.src !== (img_src_value =
      /*r*/
      ctx[6].thumb)) {
        attr_dev(img, "src", img_src_value);
      }

      if (dirty &
      /*results*/
      2 && t1_value !== (t1_value =
      /*r*/
      ctx[6].title + "")) set_data_dev(t1, t1_value);

      if (dirty &
      /*results*/
      2) {
        each_value_1 =
        /*r*/
        ctx[6].format;
        validate_each_argument(each_value_1);
        let i;

        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span0, null);
          }
        }

        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }

        each_blocks.length = each_value_1.length;
      }

      if (dirty &
      /*results*/
      2 && t4_value !== (t4_value =
      /*r*/
      ctx[6].year + "")) set_data_dev(t4, t4_value);

      if (dirty &
      /*results*/
      2 && li_data_id_value !== (li_data_id_value =
      /*r*/
      ctx[6].id)) {
        attr_dev(li, "data-id", li_data_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(li);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(23:12) {#each results as r}",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let ul;
  let dispose;
  let each_value =
  /*results*/
  ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const block = {
    c: function create() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      ul = element("ul");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      attr_dev(input, "type", "search");
      attr_dev(input, "placeholder", "Black album, Rien...");
      attr_dev(input, "class", "svelte-zl324n");
      add_location(input, file, 19, 4, 479);
      attr_dev(ul, "class", "svelte-zl324n");
      add_location(ul, file, 21, 8, 574);
      add_location(div0, file, 20, 4, 560);
      attr_dev(div1, "class", "search svelte-zl324n");
      add_location(div1, file, 18, 0, 454);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor, remount) {
      insert_dev(target, div1, anchor);
      append_dev(div1, input);
      set_input_value(input,
      /*search*/
      ctx[0]);
      append_dev(div1, t);
      append_dev(div1, div0);
      append_dev(div0, ul);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }

      if (remount) dispose();
      dispose = listen_dev(input, "input",
      /*input_input_handler*/
      ctx[5]);
    },
    p: function update(ctx, [dirty]) {
      if (dirty &
      /*search*/
      1) {
        set_input_value(input,
        /*search*/
        ctx[0]);
      }

      if (dirty &
      /*results*/
      2) {
        each_value =
        /*results*/
        ctx[1];
        validate_each_argument(each_value);
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }

        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }

        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1);
      destroy_each(each_blocks, detaching);
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let search = "";
  let results = [];
  let q, res;

  async function searchFn() {
    console.log("q = " + search);
    q = await fetch("https://api.discogs.com/database/search?q=" + search + "&type=release&key=zOXIgBWYIOOXAiDqlfLs&secret=OWkTTrjHpzDTdYABSImEJPAEkubAIqKV");
    res = await q.json();
    console.log(res);
    $$invalidate(1, results = res.results);
  }

  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Search> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Search", $$slots, []);

  function input_input_handler() {
    search = this.value;
    $$invalidate(0, search);
  }

  $$self.$capture_state = () => ({
    search,
    results,
    q,
    res,
    searchFn
  });

  $$self.$inject_state = $$props => {
    if ("search" in $$props) $$invalidate(0, search = $$props.search);
    if ("results" in $$props) $$invalidate(1, results = $$props.results);
    if ("q" in $$props) q = $$props.q;
    if ("res" in $$props) res = $$props.res;
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*search*/
    1) {
      $: if (search !== "") {
        searchFn();
      }
    }
  };

  return [search, results, q, res, searchFn, input_input_handler];
}

class Search extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-zl324n-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment.name
    });
  }

}

export default Search;